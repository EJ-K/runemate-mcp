[
  {
    "path": "",
    "title": "Welcome",
    "content": "# Welcome\n\nWelcome to the RuneMate documentation.\n\n## Useful Links\n\n- [Discord](https://discord.gg/runemate)\n- [JavaDoc](https://javadoc.runemate.com/)\n- [Community](https://www.runemate.com/community/)"
  },
  {
    "path": "getting-started/runemate-user-guide",
    "title": "RuneMate User Guide",
    "content": "# RuneMate User Guide\n\n## Using RuneMate\n\n### Finding Bots\n\nYou can discover and add bots through either the website's Store page or the in-client store by selecting the + (Add) button on the bots sidebar.\n\n### Adding an Account\n\nCharacters can be added to RuneMate by pressing the + (Add) button on the accounts sidebar. The platform supports both legacy accounts (username/password login) and Jagex Account characters.\n\n**Jagex Account**\n\nRuneMate integrates with Jagex Accounts via their official OAuth2 API, launching clients similarly to the Jagex Launcher. Account aliases should be anonymized (like 'main' or 'skiller'). Users can import characters by launching the Jagex Account Manager, configure bank PINs for automatic unlocking, and designate which skill receives lamps from Genie random events.\n\n**Legacy Account**\n\nThis option allows adding non-Jagex Accounts by completing the required form fields.\n\n### Starting a Bot\n\nThe process involves five steps:\n\n1. Select a bot from the left sidebar (bots can be pinned to the top via right-click menu)\n2. Choose an account\n3. Optionally launch a RuneLite client (or patch the Jagex Launcher as an alternative)\n4. Select a specific client\n5. Press \"Start Session\"\n\nPremium bots may offer trial versions or feature variants requiring additional payment.\n\n## Pricing\n\n### Free Tier\n\nUsers receive 200 hours monthly for free bots. Upgrading to Supporter increases this limit by 100 hours per dollar spent beyond the initial $2 investment.\n\n### Premium Bots\n\nPremium bots consume credits (purchased via PayPal or gifted) with hourly billing beginning immediately upon bot launch and continuing each hour thereafter, including during pauses. Some bots feature optional paid variants unlocking enhanced capabilities.\n\n### Refunds\n\nSessions can be refunded through the Sessions page by requesting approval from the bot author, who may request logs and issue descriptions for troubleshooting.\n\n### Cancelling Subscriptions\n\nPayPal manages all billing for Supporter subscriptions.\n\n## Security Features\n\n### RuneMate Vault\n\nThe Vault provides encrypted storage for sensitive data using a secondary password. The system operates through four key principles: local encryption using only your Vault password, automatic generation of strong random passwords by default, cloud storage with zero RuneMate access to decrypted contents, and user control over password changes via the sidebar padlock icon."
  },
  {
    "path": "getting-started/runemate-user-guide/importing-jagex-characters",
    "title": "Importing Jagex Characters",
    "content": "# Importing Jagex Characters\n\n## How to import characters\n\n**Step 1: Choose an alias**\nSelect a name for your account reference that doesn't expose sensitive details, such as 'main' or 'skiller'.\n\n**Step 2: Launch Jagex Account Manager**\nOpen the Jagex Account Manager to begin the character import process.\n\n**Step 3: Select \"Import Jagex Characters\"**\nChoose this option, which may require downloading resources to initiate the login process. This action opens the Jagex OAuth login in a separate window.\n\n**Step 4: Sign into your Jagex Account**\nComplete authentication through the Jagex login interface.\n\n**Step 5: Save Accounts**\nAfter authentication, your available characters display. Select \"Save\" to store these accounts, which are protected by the RuneMate Vault.\n\n**Step 6: Select Linked Character**\nChoose your desired character on the account creation page to complete the linking process.\n\n---\n\n## Security & Safety\n\n### Why do I need to log in?\n\nOfficial Jagex OAuth login is required to grant permission for data import. This approach ensures your password remains private -- the service only receives access to information necessary for launching clients.\n\n### Is this safe?\n\nThree protective measures are in place:\n\n- Data remains on your personal computer without uploading or transmission\n- Locally stored information is encrypted using your RuneMate Vault password\n- Client launches match those from the official Jagex Launcher\n\n### Access limitations\n\nThe service cannot authenticate as you, access private information, or execute actions on your behalf. OAuth provides only limited, read-only access to specific launch data.\n\n## Alternative: Jagex Launcher method\n\nUsers uncomfortable importing characters can launch RuneLite clients through the Jagex Launcher after applying a patch. This option appears in the \"Edit\" menu. The default Windows installation directory is `%LOCALAPPDATA%\\RuneLite`."
  },
  {
    "path": "getting-started/project-setup",
    "title": "Project Setup",
    "content": "# Project Setup\n\nTo start a new project in IntelliJ IDEA, configure these settings:\n\n## Configuration Table\n\n| Option | Value |\n|--------|-------|\n| Name | Your name in lowercase followed by \"-bots\" (e.g., \"party-bots\") |\n| Location | Local machine directory for project storage |\n| Create Git Repository | Off |\n| Build System | Gradle |\n| JDK | JDK 17 (Eclipse Temurin recommended) |\n| Gradle DSL | Kotlin preferred |\n| Add sample code | Off |\n| Gradle dist. | Wrapper |\n| Gradle version | 8.7 |\n| Group ID | Java package naming format (e.g., \"com.runemate.yourusername\") |\n| Artifact ID | Same as project name (e.g., \"party-bots\") |\n\n## Important Notes\n\nAfter project creation, allow Gradle sufficient time to complete environment configuration.\n\nTwo key interface elements to note:\n\n- **Left side**: Project Browser displays all project files\n- **Right side**: Gradle tool window provides convenient access to Gradle tasks"
  },
  {
    "path": "getting-started/gradle-plugin",
    "title": "Gradle Plugin",
    "content": "# Gradle Plugin\n\nThe RuneMate Gradle plugin streamlines bot development by handling project management and simplifying the publishing workflow."
  },
  {
    "path": "getting-started/gradle-plugin/configuration",
    "title": "Configuration",
    "content": "# Configuration\n\nTo implement the RuneMate Gradle plugin, add this to your build.gradle.kts file:\n\n```kotlin\nplugins {\n    id(\"com.runemate\") version \"1.5.2\"\n}\n\nrunemate {\n    devMode = true\n    autoLogin = true\n}\n```\n\n**Important:** Verify you're using the latest plugin version from the [Gradle plugin portal](https://plugins.gradle.org/plugin/com.runemate).\n\n## Configuration Options\n\nThe plugin supports these properties within the runemate block:\n\n| Option | Purpose | Default |\n|--------|---------|--------|\n| autoLogin | Automatic login attempt | false |\n| devMode | Developer mode launch | true |\n| debug | Debug logging | false |\n| apiVersion | Game API version | Latest |\n| pathfinderVersion | Pathfinder API version | Latest |\n| clientVersion | Client version | Latest |\n| botDirectories | Bot scan locations | `$projectDir/build/libs` |\n| allowExternalDependencies | External dependency resolution | false |\n| excludeFromSubmission | Exclude from store submission | false |\n| submissionToken | Store authentication token | Environment variable or property |\n\n## Updating RuneMate Versions\n\n**Method 1:** Refresh Gradle dependencies through IntelliJ IDEA's Gradle tool window by right-clicking your project and selecting \"Refresh Gradle Dependencies.\"\n\n**Method 2:** Manually specify versions in build.gradle.kts:\n\n```kotlin\nrunemate {\n    apiVersion = \"1.2.3\"\n    clientVersion = \"4.3.2.1\"\n}\n```\n\n## Running the Client\n\nExecute the `runClient` task via the Gradle tool window or terminal:\n\n```\n./gradlew runClient\n```"
  },
  {
    "path": "getting-started/gradle-plugin/manifests",
    "title": "Manifests",
    "content": "# Manifests\n\nThe bot manifest provides RuneMate with the information required to display and launch your bot. Gradle can be configured to generate these automatically using the **manifest** configuration block.\n\n## Configuration Structure\n\nManifest declarations generate JSON manifests in `$projectDir/build/runemate/sources/.runemate` and are automatically included in project artifacts and bot store submissions.\n\n## Required Fields\n\nEvery manifest must include:\n- `mainClass`: The entry point for your bot\n- `tagline`: A brief description\n- `description`: Detailed explanation of functionality\n- `version`: Current version number\n- `internalId`: Unique identifier\n\n## Optional Fields\n\n**Visibility & Categorization:**\n- `access`: Controls who can see the bot (PUBLIC, etc.)\n- `hidden`: Removes bot from store listing\n- `categories`: Classification options like DEVELOPER_TOOLS\n- `tags`: Searchable keywords\n\n**Resources:**\n- `resources`: Include CSS, FXML, and other assets\n\n**Monetization:**\n- `variants`: Define pricing tiers for premium versions\n- `trial`: Set trial duration and usage allowance using ISO-8601 format or Duration objects\n\n**Advanced Features:**\n- `features`: Declare required capabilities like DIRECT_INPUT\n- `obfuscation`: Specify classes to exclude from code obfuscation\n\n**Control:**\n- `skip`: Prevents manifest generation if enabled\n- `hidden`: Effectively removes the bot from the store"
  },
  {
    "path": "getting-started/gradle-plugin/publishing",
    "title": "Publishing",
    "content": "# Publishing\n\nThe plugin introduces a `submitForReview` task at the root project level. This task examines each project where the plugin is applied and executes the following operations sequentially:\n\n1. Removes any earlier submission bundles or created manifests\n2. Constructs manifests according to specifications in each project's `manifests` block\n3. Checks and verifies any user-created manifests\n4. Packages all source code, resources, and manifests into the root project's build directory\n5. Transfers the source bundle to the store for review and publication\n\n## Configuration Requirement\n\nThe `submissionToken` must be configured to use this functionality. The recommended approach involves adding a property named `runemateSubmissionToken` to your local gradle configuration file at `$USER_HOME/.gradle/gradle.properties`:\n\n```\nrunemateSubmissionToken=YOUR_TOKEN\n```\n\nYou can obtain a submission token through the [RuneMate Developer panel](https://www.runemate.com/developer).\n\n## Preview Tip\n\nTo examine what will be submitted before publishing, execute the `buildSubmission` task. This generates a compressed archive in `$rootProject/build/runemate/distribution`."
  },
  {
    "path": "getting-started/gradle-plugin/advanced-builds",
    "title": "Advanced Builds",
    "content": "# Advanced Builds\n\nUtilizing a multi-project build structure offers benefits for separating development code from production-ready code and facilitating collaboration. The Gradle plugin provides supporting tools for this setup.\n\n## Plugin Application\n\nEvery module containing source code or resources requires the Gradle plugin. You can apply it across all subprojects using a configuration block:\n\n```kts\nsubprojects {\n    apply<JavaPlugin>()\n    apply<RuneMatePlugin>()\n}\n```\n\n## Launching RuneMate\n\nThe `runClient` task gets added to all projects with the plugin applied. Running this from the Gradle tool window launches a client for each project. To prevent this behavior, disable the task in your subprojects:\n\n```kts\nsubprojects {\n    tasks.runClient {\n        enabled = false\n    }\n}\n```\n\n## Bundling Modules\n\nThe client may have difficulty locating manifests, bot classes, or resources. Create a consolidated JAR file by adding this task to your root buildscript:\n\n```kts\nval uberJar by tasks.registering(Jar::class) {\n    group = \"runemate\"\n    dependsOn(subprojects.map { it.tasks.assemble })\n    archiveBaseName.set(\"runemate-bots\")\n    subprojects.forEach {\n        from(it.sourceSets.main.get().output)\n        from(it.layout.buildDirectory.dir(\"runemate/sources/.runemate\"))\n    }\n}\n\ntasks.runClient {\n    dependsOn(uberJar)\n}\n```\n\n## Excluding Modules\n\nPrevent specific modules from being submitted to the bot store using the `excludeFromSubmission` configuration option:\n\n```kts\nrunemate {\n    // ... other configuration\n    excludeFromSubmission = true\n}\n```\n\nThis approach helps separate work-in-progress code from content ready for public release."
  },
  {
    "path": "api/querying",
    "title": "Querying",
    "content": "# Querying\n\n## Overview\n\nThe Query API serves as a tool for locating in-game entities through various filters. Queries are optimized and evaluated lazily, allowing builders to be reused efficiently.\n\n## Query Builder Hierarchy\n\nThe query builders follow a hierarchical structure:\n\n- **InteractableQueryBuilder** (base)\n  - **LocatableEntityQueryBuilder**\n    - **RotatableQueryBuilder**\n      - **ActorQueryBuilder** (with NpcQueryBuilder and PlayerQueryBuilder)\n    - Specialized builders (BankQueryBuilder, GameObjectQueryBuilder, GroundItemQueryBuilder, etc.)\n  - **SpriteItemQueryBuilder**\n  - **InterfaceComponentQueryBuilder**\n- **WorldQueryBuilder**\n- **ChatboxQueryBuilder**\n- **GrandExchangeQueryBuilder**\n- **HintArrowQueryBuilder**\n\n## Common Query Builder Types\n\n**Items**: The SpriteItemQueryBuilder searches for items in containers like inventory, equipment, or bank. Creation methods include `Inventory.newQuery()`, `Equipment.newQuery()`, `Bank.newQuery()`, and others.\n\n**Interfaces**: InterfaceComponentQueryBuilder locates interface components via `Interfaces.newQuery()`, with optimization possible through filtering on type and container.\n\n**GameObjects**: GameObjectQueryBuilder finds game objects like trees and doors. Performance improves significantly by filtering on type and location.\n\n**Other builders** exist for projectiles, ground items, and worlds.\n\n## Query Results\n\nResults are retrieved through `QueryBuilder#results()`. Convenience methods include `.first()`, `.last()`, `.random()`, `.nearest()`, and `.nearestTo()`.\n\n**Important caveat**: Queries are not guaranteed to succeed, requiring proper null checking to avoid crashes."
  },
  {
    "path": "api/delays",
    "title": "Delays",
    "content": "# Delays\n\nUsing delays in bots serves several important functions:\n\n* Mimic human behaviour\n* Avoid detection\n* Increase reliability\n* Improving performance\n\nThis is particularly relevant for RuneScape, which operates on a 600ms game tick, whereas bots can cycle much faster.\n\n## Two Delay Types\n\nRuneMate's Execution API supports both static and dynamic delays. Static delays block for a fixed duration, while dynamic delays halt execution until or while specific conditions are satisfied.\n\n## Static Delays\n\nThese provide basic blocking for a set number of milliseconds:\n\n```java\nExecution.delay(600);\n```\n\nRandom delays accept minimum and maximum values:\n\n```java\nExecution.delay(600, 1200);\n```\n\n## Dynamic Delays\n\nDynamic delays offer more sophisticated control. Consider a tree-chopping scenario where the bot would repeatedly attempt interaction before the animation actually begins.\n\nThe `delayUntil()` method waits for a condition:\n\n```java\npublic void onLoop() {\n    Player player = Players.getLocal();\n    GameObject tree = GameObjects.newQuery().names(\"Tree\").results().nearest();\n    if (player != null && tree != null && tree.interact(\"Chop\")) {\n        Execution.delayUntil(() -> player.getAnimationId() != -1, 600);\n    }\n}\n```\n\nFor more responsive behavior, a reset condition can restart the timeout:\n\n```java\nExecution.delayUntil(() -> player.getAnimationId() != -1, () -> player.isMoving(), 600);\n```\n\n**Key point**: Every delay method returns a boolean result, which is true if the condition is met before the timeout, enabling advanced control flow management."
  },
  {
    "path": "api/game-world",
    "title": "Game World",
    "content": "# Game World\n\n> Explv provides [an excellent tool](https://explv.github.io/) for browsing the world map.\n\n## World Structure\n\nThe game world is organized into a hierarchical system:\n\n| Structure | Size | Description |\n|-----------|------|-------------|\n| Region | 64x64 | A portion of the game map |\n| Chunk | 8x8 | A portion of a Region |\n| Scene | 104x104 | The portion of the map currently loaded |\n| Coordinate | 1x1 | A position on the map |\n\nThe blue grid represents Region borders, while the shaded light blue square shows the loaded Scene. Scenes can span multiple regions without fully enclosing them.\n\n### Region ID Calculation\n\nLarge white numbers on the map represent region IDs. These can be calculated from any coordinate within that region using this formula:\n\n```\ny / 64 | ((x / 64) << 8)\n```\n\n**Example:** For the Lumbridge teleport spot at coordinates (3221, 3219):\n\n```\n(3219 / 64) | (3221 / 64) << 8\n= 12850\n```\n\nThis demonstrates how the coordinate system maps to specific region identifiers within the game world."
  },
  {
    "path": "api/game-world/instances",
    "title": "Instances",
    "content": "# Instances\n\nInstances allow converting between real-world coordinates and their mapped positions within the current game instance using two key methods.\n\n## Overview\n\nUse `Coordinate.instance()` and `Coordinate.uninstance()` to transform coordinates between the \"real\" world and the current instance.\n\n## Code Example\n\nThe following example shows:\n\n1. Creating a coordinate for the south-west portal in pest control at real-world position (2645, 2572, 0)\n2. Converting it to the instanced position using `Coordinate.instance(portal)`\n3. Converting back to real-world coordinates using `Coordinate.uninstance(instancedPortal)`\n4. Verifying the result matches the original coordinate\n\n## Key Methods\n\n- **`Coordinate.instance()`** - converts a real-world coordinate to its position within the current instance\n- **`Coordinate.uninstance()`** - converts an instanced coordinate back to real-world coordinates\n\nThese operations are reversible, with the uninstanced coordinate equaling the original coordinate."
  },
  {
    "path": "api/game-world/navigation",
    "title": "Navigation",
    "content": "# Navigation\n\nRuneMate offers multiple pathfinding algorithms to simplify traversal through the game world.\n\n## Available Pathfinding Options\n\nFour main pathfinding systems are available:\n\n- **BresenhamPath** creates straight-line routes between two points\n- **ScenePath** provides fast, content-aware pathing within the current scene\n- **WayPointPath** connects multiple waypoints using ScenePath for longer journeys\n- **WebPath** handles obstacles and teleports across the full game world\n\n## Key Implementation Considerations\n\nAn important note: both the start and destination positions must be walkable before attempting pathfinding.\n\n## Specific Pathfinding Methods\n\n**BresenhamPath** generates direct lines and works well for short distances:\n\n```java\nPath path = BresenhamPath.buildTo(coordinate);\npath.step();\n```\n\n**ScenePath** mimics RuneScape's native pathing but cannot handle doors or shortcuts:\n\n```java\nPath path = ScenePath.buildTo(coordinate);\nif (path != null) {\n    path.step();\n}\n```\n\nAlways perform null checks since RuneScape is a dynamic game and queries are not guaranteed to succeed.\n\n**Pathfinder (Global)** is capable of traversing most of the game world, including teleports and obstacles, with additional documentation available separately.\n\n**WebPath (Legacy)** handles complex pathfinding but can be slow, making caching strategies worthwhile."
  },
  {
    "path": "api/game-world/global-pathfinding",
    "title": "Global Pathfinding",
    "content": "# Global Pathfinding\n\nThe **Pathfinder** system enables bots to construct traversable paths across game worlds, managing teleports and transports automatically. A single Pathfinder instance per bot session is recommended, as it registers event listeners and monitors essential context like inventory items and completed quests.\n\n## Pathfinding Algorithms\n\nThe system supports two pathfinding approaches:\n\n- **Dijkstra's Algorithm**: Guarantees the shortest path but trades speed for accuracy\n- **A* Algorithm**: More efficient but potentially less optimal; this is the default\n\n## Path Reusability and Walking\n\nPaths remain valid until invalidated by significant deviation or obstruction. The most recently computed path is retrievable via `Pathfinder#getLastPath()`. Walking behavior can be customized through `TraversalOption`s passed to the `step()` method, such as `TraversalOption.USE_DIRECT_INPUT` for direct input walking.\n\n## Implementation Guide\n\nThe library integrates automatically with RuneMate's Gradle plugin (v1.4.X+). The recommended approach involves instantiating a single Pathfinder in your bot's main class.\n\nThe PathBuilder, accessed via `Pathfinder#pathBuilder()`, configures start/destination positions and accessible transports. The `#poh()` method is particularly valuable for configuring player-owned house teleports.\n\n## Usage Example\n\n```java\nprivate Pathfinder pathfinder;\n\n@Override\npublic void onStart(String... args) {\n    pathfinder = Pathfinder.create(this);\n}\n\n@Override\npublic void onLoop() {\n    Coordinate destination = /* your destination */;\n    Path path;\n    if (pathfinder.getLastPath() != null && pathfinder.getLastPath().isValid()) {\n        path = pathfinder.getLastPath();\n    } else {\n        path = pathfinder.pathBuilder()\n            .preferAccuracy()\n            .enableMinigameTeleports(false)\n            .poh(POH.builder()\n                .mountedGlory(true)\n                .mountedXericsTalisman(true)\n                .jewelleryBoxTier(JewelleryBox.Tier.ORNATE)\n                .nexusPortal(Portal.BARROWS)\n                .build())\n            .destination(destination)\n            .findPath();\n    }\n    \n    if (path != null) {\n        path.step();\n    }\n}\n```\n\n**Important**: Initialize Pathfinder only after `onStart()`, as it requires event listener registration for proper context tracking.\n\n## Open-Source Contribution\n\nThe Pathfinder API is open-source via the RuneMate Community GitLab. Developers are encouraged to contribute improvements and expanded map coverage."
  },
  {
    "path": "api/default-user-interface",
    "title": "Default User Interface",
    "content": "# Default User Interface\n\nThe RuneMate platform automatically provides a default user interface for developers who prefer not to create their own custom interface. RuneMate will automatically use it if a custom one is not provided.\n\nThis built-in interface includes intelligent settings functionality and offers developers considerable flexibility for personalization. The system requires no additional setup or configuration to activate these default features -- they engage automatically as the fallback option when no alternative interface has been implemented."
  },
  {
    "path": "api/default-user-interface/settings",
    "title": "Settings",
    "content": "# Settings\n\nThe DefaultUI automatically generates JavaFX controls for bot settings based on an interface you create. These settings persist in StoredProperties between sessions.\n\n## Implementation Overview\n\nRuneMate scans your bot's main class for fields annotated with `@SettingsProvider` and injects setting instances. Here's the basic pattern:\n\n```java\npublic class ExampleBot extends LoopingBot {\n    @SettingsProvider(updatable = true)\n    private ExampleSettings settings;\n\n    @Override\n    public void onLoop() {\n        if (settings.logsToChop() > 1000) {\n            //Do something!\n        }\n    }\n}\n```\n\n## The Settings Descriptor\n\nCreate an interface extending `Settings` with these requirements:\n\n- Must be an interface\n- Must have `@SettingsGroup` annotation\n- Each setting uses a default method (providing the default value)\n- Each setting annotated with `@Setting` containing metadata\n\n**Example:**\n\n```java\n@SettingsGroup\npublic interface ExampleSettings extends Settings {\n    @Setting(key = \"logsToChop\", title = \"Logs to Chop\", \n             description = \"How many logs the bot should chop\")\n    default int logsToChop() {\n        return 1000;\n    }\n}\n```\n\n## @SettingsGroup\n\nThis class-level annotation identifies the interface as a settings descriptor. The optional `group` parameter provides version control.\n\n## @Setting Attributes\n\n| Attribute | Description |\n|-----------|-------------|\n| key | Unique identifier for persistent storage |\n| title | UI label for the setting |\n| order | Display order (ascending) |\n| secret | For Strings -- masks as password |\n| disabled | Disables the UI element |\n| hidden | Hides the UI element |\n| description | Tooltip text on hover |\n| section | Grouping section (defaults to \"General\") |\n| converter | SettingsConverter for custom types |\n\n## Special Annotations\n\n- **@Range** - For `int` settings; specifies min, max, and step values\n- **@Suffix** - For `int` settings; appends text (e.g., \"gp\") to displayed values\n- **@Multiline** - For `String` settings; uses TextArea instead of TextField\n\n## Programmatic Value Assignment\n\nAdd a setter method matching the getter's key to modify settings programmatically:\n\n```java\n@Setting(key = \"logsToChop\", title = \"Logs to Chop\", \n         description = \"How many logs the bot should chop\")\ndefault int logsToChop() {\n    return 1000;\n}\n\n@Setting(key = \"logsToChop\", title = \"\")\nvoid setLogsToChop(int logs);\n```"
  },
  {
    "path": "api/varps-varbits-and-varcs",
    "title": "Varps, Varbits and Varcs",
    "content": "# Varps, Varbits and Varcs\n\nVars function as state management tools within the game engine. There are three types:\n\n## Varps\n\nThese are 32-bit integers representing the most fundamental var type. They're server-controlled and updated client-side each tick.\n\n```java\nint value = Varps.getAt(ALCHEMY_WARNING_VARP).getValue();\n```\n\n## Varbits\n\nBuilt upon Varps, these variables have flexible sizes determined by game cache specifications. Each maintains a fixed size according to its definition.\n\n```java\nVarbit varbit = Varbits.load(id);\nint value = varbit.getValue();\n```\n\n## Varcs\n\nClient-side only variables primarily utilized in client scripts with optional persistence. They accommodate both integer and string data types, commonly storing chat input and similar client state.\n\n```java\nString varcString = Varcs.getString(id);\nint varcInt = Varcs.getInt(id);\n```\n\n## Locating Vars\n\nThe Development Toolkit's Events pane provides the optimal method for identifying vars. For NPC or GameObject transformations, developers can examine the relevant Definition classes to locate associated Varps or Varbits."
  },
  {
    "path": "api/events",
    "title": "Events",
    "content": "# Events\n\nEvents provide an efficient mechanism for responding to game engine changes like NPC spawning, skill level-ups, or variable modifications. RuneMate supplies multiple listeners to support this functionality.\n\n## Listeners\n\nThe EventListener interfaces can be implemented to react to various in-game events. For instance, the EngineListener allows code execution on every game tick:\n\n```java\npublic class MyEngineListener implements EngineListener {\n\n    private int tick;\n\n    @Override\n    public void onEngineEvent(EngineEvent event) {\n        if (event.getType() == EngineEvent.Type.SERVER_TICK) {\n            tick++;\n        }\n    }\n\n}\n```\n\n## Event Dispatcher\n\nThe EventDispatcher serves as the foundation of the event framework. All listeners require registration through it. Your bot instance provides an EventDispatcher:\n\n```java\npublic class MyBot extends LoopingBot {\n\n    private MyEngineListener listener;\n    \n    @Override\n    public void onStart(String... args) {\n        getEventDispatcher().addListener(listener);\n    }\n}\n```"
  },
  {
    "path": "api/concepts",
    "title": "Concepts",
    "content": "# Concepts\n\n## Orientations\n\nIn OSRS, orientations are typically represented in JAU between 0-2048, where zero indicates facing directly south. Each increment corresponds to `(1 / 2048f) * 360 = 0.17578125` degrees of clockwise rotation.\n\n## Interface IDs\n\nThe game engine organizes InterfaceComponents (commonly called Widgets) in a 2-dimensional array structure. Each Widget's identifier is calculated based on its position using this formula:\n\n```\ncomponentId = containerIndex << 16 | componentIndex\n```\n\nTo retrieve a specific component, the inverse calculation applies:\n\n```java\nInterfaceComponent ic = Interfaces.getAt(componentId >> 16, componentId & 0xFFFF);\n```"
  }
]
